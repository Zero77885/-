shell是一个**命令行解释器**,它接收应用程序/用户命令.然后调用操作系统内核

shell 脚本以#!/bin/bash开头

# 特殊变量

## $n

$n  （功能描述：n为数字，$0代表该脚本名称，$1-$9代表第一到第九个参数，十以上的参数需要用大括号包含，如${10}。

## $#

$#  （功能描述：获取所有输入参数个数，常用于循环，判断参数的个数是否正确以及加强脚本的健壮性）

# $*、$@

$*  （功能描述：这个变量代表命令行中所有的参数，$*把所有的参数看成一个整体）

$@ （功能描述：这个变量也代表命令行中所有的参数，不过$@把每个参数区分对待）

# $？

$？ （功能描述：最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值为非0（具体是哪个数，由命令自己来决定），则证明上一个命令执行不正确了）

# 运算符

“$((运算式))” 或 “$[运算式]”

```shell
#计算（2+3）* 4的值
S=$[(2+3)*4]
echo $S
```

# 条件判断

（1）test condition

（2）[ condition ]（注意condition前后要有空格）

注意：条件非空即为true，[ atguigu ]返回true，[ ] 返回false。

## 常用判断条件

### 两个整数之间比较

-eq 等于（equal）

-ne 不等于（not equal）

 -lt 小于（less than）

-le 小于等于（less equal）

-gt 大于（greater than）

-ge 大于等于（greater equal）  

### 按照文件权限进行判断

-r 有读的权限（read） 

-w 有写的权限（write）

-x 有执行的权限（execute）

### 按照文件类型进行判断

-e 文件存在（existence）

-f 文件存在并且是一个常规的文件（file）

-d 文件存在并且是一个目录（directory）

# 流程控制

## if判断

```shell
#（1）单分支
if [ 条件判断式 ];then 
    程序 
fi 
#或者
if  [ 条件判断式 ] 
then 
    程序 
fi
#（2）多分支
if [ 条件判断式 ] 
then 
    程序 
elif [ 条件判断式 ]
then
	程序
else
	程序
fi
```

## case语句

```shell
case $变量名 in 
"值1"） 
  如果变量的值等于值1，则执行程序1 
;; 
"值2"） 
  如果变量的值等于值2，则执行程序2 
;; 
  …省略其他分支… 
*） 
  如果变量的值都不是以上的值，则执行此程序 
;; 
esac
```

## for循环

```shell
#基本for循环
for (( 初始值;循环控制条件;变量变化 )) 
do 
    程序 
done

#增强for循环
for 变量 in 值1 值2 值3… 
do 
    程序 
done
```

# while循环

```shell
while [ 条件判断式 ] 
do 
    程序
done
```

# 读取控制台输入

read （选项） （参数）

**选项：**

-p：指定读取值时的提示符。

-t：指定读取值时等待的时间（秒）如果-t不加表示一直等待。

**参数**

变量：指定读取值的变量名。

# 系统函数

## 取路径里的文件名称

basename [string / pathname] [suffix]     （功能描述：basename命令会删掉所有的前缀包括最后一个（‘/’）字符，然后将字符串显示出来）

basename 可以理解为取路径里的文件名称。

选项：

suffix为后缀，如果suffix被指定了，basename会将pathname或string中的suffix去掉。

## 取文件路径的绝对路径名称

dirname 文件绝对路径    （功能描述：从给定的包含绝对路径的文件名中去除文件名（非目录的部分），然后返回剩下的路径（目录的部分））

dirname 可以理解为取文件路径的绝对路径名称。

## 自定义函数

```shell
[ function ] funname[()]
{
	Action;
	[return int;]
}
```

# cut在文件中剪切数据

cut [选项参数] filename

说明：默认分隔符是制表符

| **选项参数** | **功能**                                       |
| ------------ | ---------------------------------------------- |
| **-f**       | 列号，提取第几列                               |
| **-d**       | 分隔符，按照指定分隔符分割列，默认是制表符“\t” |
| **-c**       | 按字符进行切割 后加加n 表示取第几列 比如 -c 1  |

# awk以空格为默认分隔符将每行切片

awk [选项参数] ‘/pattern1/{action1} /pattern2/{action2}...’ filename

pattern：表示awk在数据中查找的内容，就是匹配模式。

action：在找到匹配内容时所执行的一系列命令。

| **选项参数** | **功能**             |
| ------------ | -------------------- |
| **-F**       | 指定输入文件折分隔符 |
| **-v**       | 赋值一个用户定义变量 |

**awk的内置变量**

| **变量**     | **说明**                               |
| ------------ | -------------------------------------- |
| **FILENAME** | 文件名                                 |
| **NR**       | 已读的记录数（行号）                   |
| **NF**       | 浏览记录的域的个数（切割后，列的个数） |

# 正则表达式

## 特殊字符：^

```shell
cat /etc/passwd | grep ^a #会匹配出所有以a开头的行。
```



## 特殊字符：$

```shell
cat /etc/passwd | grep t$ 会匹配出所有以t结尾的行。
```

## 特殊字符：.

```shell
cat /etc/passwd | grep r..t #会匹配包含rabt,rbbt,rxdt,root等的所有行
```

## 特殊字符：*

```shell
cat /etc/passwd | grep ro*t
#表示匹配上一个字符0次或多次
#会匹配rt, rot, root, rooot, roooot等所有行。
```

## 特殊字符：[ ]

[ ] 表示匹配某个范围内的一个字符，例如

[6,8]------匹配6或者8

[0-9]------匹配一个0-9的数字

[0-9]*------匹配任意长度的数字字符串

[a-z]------匹配一个a-z之间的字符

[a-z]* ------匹配任意长度的字母字符串

[a-c, e-f]-匹配a-c或者e-f之间的任意字符

[atguigu@hadoop101 shells]$ cat /etc/passwd | grep r[a,b,c]*t

会匹配rt,rat, rbt, rabt, rbact,rabccbaaacbt等等所有行。

## 特殊字符：\

\ 表示转义

```shell
cat /etc/passwd | grep a\$b
#会匹配所有包含 a$b 的行。
```

